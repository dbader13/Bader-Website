<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Projects | David A. Bader</title>
    <link>http://localhost:1313/projects/</link>
      <atom:link href="http://localhost:1313/projects/index.xml" rel="self" type="application/rss+xml" />
    <description>Projects</description>
    <generator>Hugo Blox Builder (https://hugoblox.com)</generator><language>en-us</language><lastBuildDate>Mon, 30 Jun 2025 00:08:59 -0500</lastBuildDate>
    <image>
      <url>http://localhost:1313/media/sharing.jpg</url>
      <title>Projects</title>
      <link>http://localhost:1313/projects/</link>
    </image>
    
    <item>
      <title>Scalable Algorithmic and Software Foundations for Subgraph Counting and Enumeration</title>
      <link>http://localhost:1313/projects/subgraphcounting/</link>
      <pubDate>Mon, 30 Jun 2025 00:08:59 -0500</pubDate>
      <guid>http://localhost:1313/projects/subgraphcounting/</guid>
      <description>&lt;p&gt;This award supports the development of advanced computational methods for tracking and analyzing evolving patterns in large-scale networks. Patterns of connections among entities, known as subgraphs, underpin insights in domains such as social interactions, biological processes, financial transactions, and communication systems. Real-time analysis of how these patterns form and dissolve can enable early detection of disease outbreaks, improved understanding of social dynamics, and enhanced network security. By creating scalable and accessible tools for dynamic network analysis, this project will advance the national interest in data-driven discovery across science, technology, and public welfare.&lt;/p&gt;
&lt;p&gt;The project will pursue three integrated research thrusts. First, it will develop novel algorithms with provable efficiency guarantees for counting and enumerating subgraphs in the batch-dynamic model on parallel and distributed systems. Second, it will design and implement high-level programming frameworks and data structures tailored to dynamic graph workloads, including graphics processing unit (GPU) and distributed implementations, to facilitate practical adoption. Third, it will integrate the new algorithms and frameworks into an open-source analysis platform and conduct comprehensive evaluations on high-performance computing clusters and cloud resources. These efforts will yield the first provably-optimal dynamic subgraph counting algorithms for higher-order patterns, query-based enumeration techniques, and user-friendly software enabling researchers to perform real-time analysis on evolving networks.&lt;/p&gt;
&lt;h2 id=&#34;investigators&#34;&gt;Investigators:&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;David Bader, New Jersey Institute of Technology (Principal Investigator: CCF-2453324)&lt;/li&gt;
&lt;li&gt;Quanquan Liu, Yale University (Principal Investigator CCF-2453323)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;links&#34;&gt;Links&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.nsf.gov/awardsearch/showAward?AWD_ID=2453324&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;NSF OAC-2453324&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://news.njit.edu/research-njit-and-yale-leads-trio-computing-innovations&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Research from NJIT and Yale Leads to Trio of Computing Innovations&lt;/a&gt;, NJIT News, 29 July 2025.&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Cyber-Infrastructure for Community Detection, Extraction, and Search in Large Networks</title>
      <link>http://localhost:1313/projects/scientometrics/</link>
      <pubDate>Fri, 23 Aug 2024 00:08:59 -0500</pubDate>
      <guid>http://localhost:1313/projects/scientometrics/</guid>
      <description>&lt;p&gt;Community detection methods enable an understanding of the structure of networks at multiple scales. While many methods exist, only a few are able to scale to large networks and/or are implemented in large computational infrastructure. As we have recently shown, even those that scale to large datasets, fail to reliably produce well-connected clusters. Finally, given that the choice of clustering method depends on both the network being analyzed and the question of interest, providing the domain specialist a choice of multiple clustering methodologies within a common framework for exploratory data analysis, is essential. This project will make substantial advances on these challenges through the coordinated development of advanced cyber-infrastructure, scalable to very large networks, that offers multiple options for community detection, search, and extraction. The infrastructure will be accessible across platforms ranging from laptops to multi-node clusters with distributed memory.&lt;/p&gt;
&lt;h2 id=&#34;investigators&#34;&gt;Investigators:&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;David Bader, New Jersey Institute of Technology (Principal Investigator: OAC-2402560)&lt;/li&gt;
&lt;li&gt;Tandy Warnow, University of Illinois Urbana-Champaign (Principal Investigator OAC-2402559)&lt;/li&gt;
&lt;li&gt;George Chacko, University of Illinois Urbana-Champaign  (co-Principal Investigator OAC-2402559)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;links&#34;&gt;Links&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://sites.google.com/view/oac2402559/home&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Project website&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.nsf.gov/awardsearch/showAward?AWD_ID=2402560&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;NSF OAC-2402560&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://news.njit.edu/njit-and-illinois-research-data-analytics-will-measure-impact-scientific-literature&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;NJIT and Illinois Research on Data Analytics Will Measure Impact of Scientific Literature&lt;/a&gt;, NJIT News, 26 August 2024.&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>High Performance Algorithms for Interactive Data Science at Scale</title>
      <link>http://localhost:1313/projects/hpda/</link>
      <pubDate>Wed, 24 Feb 2021 10:08:59 -0500</pubDate>
      <guid>http://localhost:1313/projects/hpda/</guid>
      <description>&lt;p&gt;A real-world challenge in data science is to develop interactive methods for quickly analyzing new and novel data sets that are potentially of massive scale. This award will design and implement fundamental algorithms for high performance computing solutions that enable the interactive large-scale data analysis of massive data sets. Based on the widely-used data types and structures of strings, sets, matrices and graphs, this methodology will produce efficient and scalable software for three classes of fundamental algorithms that will drastically improve the performance on a wide range of real-world queries or directly realize frequent queries. These innovations will allow the broad community to move massive-scale data exploration from time-consuming batch processing to interactive analyses that give a data analyst the ability to comprehensively, deeply and efficiently explore the insights and science in real world data sets. By enabling the increasing number of developers to easily manipulate large data sets, this will greatly enlarge the data science community and find much broader use in new communities. Materials from this project will be included in graduate and undergraduate course curriculum. Especially, women, high school students and other underrepresented groups in STEM areas will be encouraged to participate in this research activity.&lt;/p&gt;
&lt;p&gt;This project focuses on these three important data structures for data analytics: 1) suffix array construction, 2) &amp;rsquo;treap&amp;rsquo; construction and 3) distributed memory join algorithms, useful for analyzing large scale strings, implementing random search in large string data sets, and generating new relations, respectively. These fundamental algorithms serve as the cornerstone to support interactive data science at scale. Based on the theoretical achievements and systematic algorithm design, a novel symbiotic optimization methodology that can combine the theoretical analysis, data structure features, and typical data distribution features together as a whole will be developed to significantly improve the practical performance of the proposed algorithms. To evaluate and show the effectiveness of the proposed algorithms, these algorithms will be implemented in and contribute to an open source NumPy-like software framework that aims to provide productive data discovery tools on massive, dozens-of-terabytes data sets by bringing together the productivity of Python with world-class high performance computing.&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://nsf.gov/awardsearch/showAward?AWD_ID=2109988&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;NSF CCF-2109988&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>NVIDIA AI Lab (NVAIL) for Scalable Graph Algorithms</title>
      <link>http://localhost:1313/projects/nvidia-nvail/</link>
      <pubDate>Mon, 05 Aug 2019 10:39:06 -0400</pubDate>
      <guid>http://localhost:1313/projects/nvidia-nvail/</guid>
      <description>&lt;h2 id=&#34;research-directions&#34;&gt;Research Directions&lt;/h2&gt;
&lt;p&gt;Graph algorithms represent some of the most challenging known problems in computer science for modern processors.  These algorithms contain far more memory access per unit of computation than traditional scientific computing.  Access patterns are not known until execution time and are heavily dependent on the input data set.  Graph algorithms vary widely in the volume of spatial and temporal locality that is usable my modern architectures. In today&amp;rsquo;s rapidly evolving world, graph algorithms are used to make sense of large volumes of data from news reports, distributed sensors, and lab test equipment, among other sources connected to worldwide networks.  As data is created and collected, dynamic graph algorithms make it possible to compute highly specialized and complex relationship metrics over the entire web of data in near-real time, reducing the latency between data collection and the capability to take action.&lt;/p&gt;
&lt;p&gt;With this partnership with NVIDIA, we collaborate on the design and implementation of scalable graph algorithms and graph primitives that will bring new capabilities to the broader community of data scientists.  Leveraging existing open frameworks, this effort will improve the experience of graph data analysis using GPUs by improving tools for analyzing graph data, speeding up graph traversal using optimized data structures, and accelerating computations with better runtime support for dynamic work stealing and load balancing.&lt;/p&gt;
&lt;h2 id=&#34;selected-projects&#34;&gt;Selected Projects:&lt;/h2&gt;
&lt;h3 id=&#34;cugraph&#34;&gt;cuGraph&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;Problem&lt;/strong&gt;&lt;/em&gt;: With the rapid advance of AI and Machine Learning, demand has surged for expertise at all levels in the workforce.  Through our educational mission, we may accelerate the development of AI frameworks such as &lt;a href=&#34;https://github.com/rapidsai/cugraph&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;RAPIDS AI cuGraph&lt;/a&gt; that builds upon our Hornet streaming graph framework for accelerators such as NVIDIA GPUs.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;Our approach&lt;/strong&gt;&lt;/em&gt;: The focus of our collaboration will design and implement scalable graph algorithms and primitives that will enable the broader data science community to make broadly accessible high-performance graph analytics. This includes faster loading of data onto the GPU, improving the performance of the underlying data structure of cuGraph, and creating better loading balancing mechanisms for graph traversals.&lt;/p&gt;
&lt;h3 id=&#34;accelerators&#34;&gt;Accelerators&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;Problem&lt;/strong&gt;&lt;/em&gt;: There are a wide variety of accelerators available today including quantum annealers, TPUs, and GPUs. These accelerators are considered key to opening the door to new applications that cannot run in a reasonable time on CPUs. However, these accelerators come with some large pitfalls: they have larger latencies, lower bandwidth, and reduced memory capacity compared to CPU main memory. This is challenging for memory-intensive applications, especially graph processing, which severely limits the impact of these accelerators for graph applications.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;Our approach&lt;/strong&gt;&lt;/em&gt;: We will investigate algorithm-specific graph decomposition. This could include partitioning in some cases, but would extend in general to breaking a graph into smaller graphs, which may not be subgraphs (induced or otherwise) but which, when solved, will result in a solution to the original graph problem. We will investigate decomposition approaches for NVIDIA GPUs in which large graphs (greater than 20 billion edges) are unexpected to fit into GPU memory for some time. We will leverage decomposition results from graph theory, for example applications such as the Embedding Lemma due to the Szemeredi Regularity Lemma, and apply them to graph problems which are currently, at scale, intractable on CPUs and will not fit on today&amp;rsquo;s accelerators.&lt;/p&gt;
&lt;h3 id=&#34;exploiting-graph-structure&#34;&gt;Exploiting Graph Structure&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;Problem&lt;/strong&gt;&lt;/em&gt;: Some graph problems are exceedingly difficult on general graphs and some heuristics or approximations are too expensive to run on graphs at large scale. One of the issues is that generappl graphs are one of the most challenging data structures to leverage for performance due to the limited locality of data access and reuse. They introduce arbitrary memory access patterns, have limited or no bounds on traversals, do not partition well, etc. The lack of structure is a significant challenge and a large amount of computational science research is done to mitigate many of these issues. In some cases this work is successful, but there are entire areas where graph analysis does not have both effective and mathematically understood approaches for solving, such as the approximate graph matching problem.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;Our approach&lt;/strong&gt;&lt;/em&gt;: We will investigate structure in existing real-world graphs and design new approaches to exploit these features for performance on accelerators. If this structure is designed well enough, then the algorithm can run approximately if the structure does not exist and exactly if it does exist, with an approximation factor based on some distance that the graph has to the structure. We can apply structural methods toward hard problems such as approximate graph matching.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Facebook Research</title>
      <link>http://localhost:1313/projects/facebook2019/</link>
      <pubDate>Mon, 05 Aug 2019 10:24:25 -0400</pubDate>
      <guid>http://localhost:1313/projects/facebook2019/</guid>
      <description>&lt;h2 id=&#34;facebook-ai-systems-hardwaresoftware-co-design-research-award-on-scalable-graph-learning-algorithms&#34;&gt;Facebook AI Systems Hardware/Software Co-Design research award on Scalable Graph Learning Algorithms&lt;/h2&gt;
&lt;h2&gt;&lt;a href=&#34;https://research.fb.com/blog/2019/05/announcing-the-winners-of-the-ai-system-hardware-software-co-design-research-awards/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://research.fb.com/blog/2019/05/announcing-the-winners-of-the-ai-system-hardware-software-co-design-research-awards/&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Deep learning has boosted the machine learning field at large and created significant increases in the performance of
tasks including speech recognition, image classification, object detection, and recommendation. It has opened the door
to complex tasks, such as self-driving and super-human image recognition. However, the important techniques used in
deep learning, e.g. convolutional neural networks, are designed for Euclidean data type and do not directly apply on
graphs. This problem is solved by embedding graphs into a lower dimensional Euclidean space, generating a regular
structure. There is also prior work on applying convolutions directly on graphs and using sampling to choose
neighbor elements. Systems that use this technique are called graph convolution networks (GCNs). GCNs have proven
to be successful at graph learning tasks like link prediction and graph classification. Recent work has pushed the
scale of GCNs to billions of edges but significant work remains to extend learned graph systems beyond
recommendation systems with specific structure and to support big data models such as streaming graphs.&lt;/p&gt;
&lt;p&gt;This project will focus on developing scalable graph learning algorithms and implementations that open the door for
learned graph models on massive graphs. We plan to approach this problem in two ways. First, developing a scalable
high performance graph learning system based on existing GCNs algorithms, like GraphSage, by improving the
workflow on shared-memory NUMA machines, balancing computation between threads, optimizing data movement,
and improving memory locality. Second, we will investigate graph learning algorithm-specific decompositions and
develop new strategies for graph learning that can inherently scale well while maintaining high accuracy. This includes
traditional partitioning, however in general we consider breaking the problem into smaller pieces, which, when solved
will result in a solution to the bigger problem. We will explore decomposition results from graph theory, for example,
forbidden graphs and the Embedding Lemma, and determine how to apply such results into the field of graph learning.
We will investigate whether these decompositions could assist in a dynamic graph setting.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>HORNET</title>
      <link>http://localhost:1313/projects/hornet/</link>
      <pubDate>Tue, 01 May 2018 07:29:53 -0400</pubDate>
      <guid>http://localhost:1313/projects/hornet/</guid>
      <description></description>
    </item>
    
    <item>
      <title>STINGER</title>
      <link>http://localhost:1313/projects/stinger/</link>
      <pubDate>Mon, 01 Jan 2018 07:11:47 -0400</pubDate>
      <guid>http://localhost:1313/projects/stinger/</guid>
      <description>&lt;p&gt;Dynamic graphs are all around us.  Social networks containing interpersonal relationships and communication patterns. Information on the Internet, Wikipedia, and other datasources.  Disease spread networks and bioinformatics problems.  Business intelligence and consumer behavior.  The right software can help to understand the structure and membership of these networks and many others as they change at speeds of thousands to millions of updates per second.&lt;/p&gt;
&lt;h3 id=&#34;motivation&#34;&gt;Motivation&lt;/h3&gt;
&lt;p&gt;The application of graph analysis has proven to be a useful abstraction for solving many important problems accross a variety of disciplines.  In graph analysis, physical objects, abstract concepts, and other entities are represented as a set of vertices and the relationships between them are represented as edges that connect two vertices together.  For example, vertices might include people, Twitter usernames, computers, cars, words, emotions, countries, events like Facebook wall posts - nearly anything.  Edges might include relationships like &amp;ldquo;talks to&amp;rdquo;, &amp;ldquo;lives in&amp;rdquo;, &amp;ldquo;friends with&amp;rdquo;, &amp;ldquo;contains&amp;rdquo;, &amp;ldquo;retweets&amp;rdquo;, or &amp;ldquo;posts on Facebook wall&amp;rdquo; - again, nearly any relationship.  You may have noticed that the wall post example was given as both a vertex and an edge.  This is because how you encode events and relationships is up to you.   You could decide that these posts will be vertices and that relationships to each event might include &amp;ldquo;authored by&amp;rdquo;, &amp;ldquo;commented on by&amp;rdquo;, &amp;ldquo;liked by&amp;rdquo;, etc.  Similarly, you could decide that you would like to store a graph containing who posts on whose wall.  As an trivial and somewhat frivolous example, consider the graph below consisting of the vertex types &amp;ldquo;people&amp;rdquo; and &amp;ldquo;things that are eaten&amp;rdquo; and the edge types &amp;ldquo;friends with&amp;rdquo; and &amp;ldquo;eats&amp;rdquo;.&lt;/p&gt;


















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /projects/stinger/test_hu_7038512f12e05809.webp 400w,
               /projects/stinger/test_hu_bd9fcdd75d5e750b.webp 760w,
               /projects/stinger/test_hu_fd9b32483251b3ab.webp 1200w&#34;
               src=&#34;http://localhost:1313/projects/stinger/test_hu_7038512f12e05809.webp&#34;
               width=&#34;479&#34;
               height=&#34;451&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;

&lt;p&gt;Many problems today can be formulated as dynamic spatio-temporal graph problems. For example, one may wish to track communities within social networks on Facebook as edges (friendship pairs) are added or removed. Or more interestingly, one may look for people who bridge between different social communities, or switch allegiances over time.&lt;/p&gt;
&lt;p&gt;As the computer science community increases its development of algorithms and codes for large-scale graph problems, no canonical graph representation has yet to emerge. Without a standard graph representation, algorithms that are implemented for one framework may require substantial programming efforts to port to a different framework. Even worse, algorithms within a single framework may use different data structures for each graph kernel, requiring costly data transformations between each graph kernel subroutine. These inefficiencies in time, space, and productivity, could be reduced or eliminated through a canonical graph representation.&lt;/p&gt;
&lt;h3 id=&#34;objectives&#34;&gt;Objectives&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Portability: Algorithms written for STINGER can easily be translated/ported between multiple languages and frameworks.  Users should be able to build and run STINGER on as many platforms as possible, and STINGER should provide support for productivity languages where possible.&lt;/li&gt;
&lt;li&gt;Productivity: STINGER should provide a common abstract data structure such that the large graph community can quickly leverage each others&amp;rsquo; research developments. This is similar in philosophy to the numerical algorithms community implicit use of sparse and dense matrices.&lt;/li&gt;
&lt;li&gt;Performance: It is recognized that no single data structure is optimal for every graph algorithm. The objective of STINGER is to configure a sensible data structure that can run most algorithms well. There should be no significant performance reduction for using STINGER when compared with another general data structure across a broad set of typical graph algorithms. STINGER should assume a shared memory address space, and allow both sequential or parallel algorithms. The data structure should allow parallel algorithms to exploit concurrency where possible.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;stinger&#34;&gt;STINGER&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;STINGER&lt;/strong&gt; is a data structure for storing sparse dynamic graphs with temporal and semantic information encoded in the graph.  This means that vertices in the graph have types (people, usernames, events, words, etc.) and weights, and that edges in the graph have types (friends with, sends email to, near to), weights, and timestamps (which we treat as created and modified).  What the types, weights, and timestamps really mean is up to the user.  As a data structure, STINGER can be extended to store more or less information with each vertex and edge as the user sees fit.  A basic diagram from the original technical report defining STINGER can be seen below; however, the API for STINGER is designed to abstract away the details of the structure and simply present an interface to vertices with a set of adjacent vertices stored in edges, all having different properties that can be retrieved and set.&lt;/p&gt;


















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /projects/stinger/stinger_design_hu_44f44f4b26ed9af5.webp 400w,
               /projects/stinger/stinger_design_hu_f5fb5a17ccf52198.webp 760w,
               /projects/stinger/stinger_design_hu_ce40e2b788cf0cf5.webp 1200w&#34;
               src=&#34;http://localhost:1313/projects/stinger/stinger_design_hu_44f44f4b26ed9af5.webp&#34;
               width=&#34;760&#34;
               height=&#34;645&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;

&lt;p&gt;For the detail-oriented users, the data structure is similar to an adjacency list except that the adjacencies of a vertex are stored in a linked list of semi-dense blocks of edges rather than a linked list of individual edges.  Also, the vertex array contains more metadata per each vertex than just a pointer to the linked of edge blocks.  As you can see, vertices have physical identifiers (an arbitrary byte string that maps to that vertex), types (an arbitraty 64-bit integer value), weights (also an arbitrary 64-bit integer value), in and out degrees (set by the structure when edges are inserted and removed), and a list of adjacencies.  Edge blocks contain meta data about all edges in the block including the type (so all edges in a block are of the same type).&lt;/p&gt;
&lt;p&gt;The fact is that STINGER is also more than just this data structure.  STINGER is also software and a collection of tools and algorithms that can process on these dynamic graphs to help us understand more about the data that we have.&lt;/p&gt;
&lt;h3 id=&#34;stinger-features&#34;&gt;STINGER Features&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Fast insertions, deletions, and updates:&lt;/strong&gt;  &lt;br&gt;
A data structure that grows and changes at the speed of the data.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Edge and vertex types and weights:&lt;/strong&gt; &lt;br&gt;
Represent complex relationships and multiple simultaneous networks.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Filtering traversal mechanisms:&lt;/strong&gt; &lt;br&gt;
Traverse serially or in parallel on specific edge types, time ranges, vertex sets, etc.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Experimental workflow server:&lt;/strong&gt; &lt;br&gt;
Multiple data streams and analytics with one persistent data structure.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Experimental Java and Python bindings:&lt;/strong&gt; &lt;br&gt;
Use efficiency-oriented languages without sacrificing performance-oriented results.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;algorithms-implemented-in-stinger&#34;&gt;Algorithms Implemented in STINGER&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Streaming edge insertions and deletions:&lt;/strong&gt; &lt;br&gt;
Performs new edge insertions, updates, and deletions in batches or individually.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Streaming clustering coefficients:&lt;/strong&gt; &lt;br&gt;
Tracks the local and global clustering coefficients of a graph under both edge insertions and deletions.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Streaming connected components:&lt;/strong&gt; &lt;br&gt;
Accurately tracks the connected components of a graph with insertions and deletions.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Streaming community detection:&lt;/strong&gt; &lt;br&gt;
Track and update the community structures within the graph as they change.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Parallel agglomerative clustering:&lt;/strong&gt; &lt;br&gt;
Find clusters that are optimized for a user-defined edge scoring function.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Streaming Betweenness Centrality:&lt;/strong&gt; &lt;br&gt;
Find the key points within information flows and structural vulnerabilities.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;K-core Extraction:&lt;/strong&gt; &lt;br&gt;
Extract additional communities and filter noisy high-degree vertices.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Classic breadth-first search:&lt;/strong&gt; &lt;br&gt;
Performs a parallel breadth-first search of the graph starting at a given source vertex to find shortest paths.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;stinger-features-1&#34;&gt;STINGER Features&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Speed:&lt;/strong&gt; millions of updates per second on commodity hardware.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Scale:&lt;/strong&gt; graphs with millions to billions of vertices and edges.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Simplicity:&lt;/strong&gt; simple code with provided conveniences to allow developers to focus on the algorithms and data, not the data structure.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Flexible:&lt;/strong&gt; Full client-server framework supports multiple simultaneous ingest streams and live output to rich web visualizations&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Built for analytics&lt;/strong&gt;
.* Vertices with:
..* Vertex Type
..* Weight
..* Physical Indices
..* In-degree
..* Out-degree
..* Edge List
..* Developer-extendable attributes
.* Edges with:
..* Edge Type
..* Weight
..* Timestamps
..* Adjacent vertices of any type
..* Developer-extendable attributes&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>cuSTINGER</title>
      <link>http://localhost:1313/projects/custinger/</link>
      <pubDate>Sun, 01 Jan 2017 07:28:09 -0400</pubDate>
      <guid>http://localhost:1313/projects/custinger/</guid>
      <description></description>
    </item>
    
    <item>
      <title>GTfold</title>
      <link>http://localhost:1313/projects/gtfold/</link>
      <pubDate>Thu, 01 Jan 2015 07:47:41 -0400</pubDate>
      <guid>http://localhost:1313/projects/gtfold/</guid>
      <description>&lt;p&gt;The GTfold package includes fast, scalable multicore code for predicting RNA secondary structure that is one to two orders of magnitude faster than the de facto standard programs and achieves comparable accuracy of prediction.&lt;/p&gt;
&lt;p&gt;We are seeing a paradigm shift to multicore chips and parallelism must be explicitly addressed to continue gaining performance with each new generation of systems. GTfold, which is implemented in C/C++ and uses OpenMP primitives for parallelization of the algorithm, opens up a new path for the algorithmic improvements and the application of improved thermodynamic models to increase prediction accuracy.&lt;/p&gt;
&lt;p&gt;GTfold now includes related programs such as RNAStructProfiling, RNAStructViz, and NNTMParameterEditor. The details of these additional programs can be found on the Github page; details for compiling and running RNA profiling can be found on the Related page.&lt;/p&gt;
&lt;p&gt;If you wish to download and compile GTfold from the latest source code, please visit the Develop page or the Github page.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>GraphBLAS</title>
      <link>http://localhost:1313/projects/graphblas/</link>
      <pubDate>Thu, 12 Sep 2013 22:05:10 -0400</pubDate>
      <guid>http://localhost:1313/projects/graphblas/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Graph500</title>
      <link>http://localhost:1313/projects/graph500/</link>
      <pubDate>Mon, 15 Nov 2010 07:45:05 -0400</pubDate>
      <guid>http://localhost:1313/projects/graph500/</guid>
      <description></description>
    </item>
    
    <item>
      <title>GraphCT: Graph Characterization Toolkit</title>
      <link>http://localhost:1313/projects/graphct/</link>
      <pubDate>Mon, 22 Feb 2010 07:40:26 -0400</pubDate>
      <guid>http://localhost:1313/projects/graphct/</guid>
      <description>&lt;h3 id=&#34;data-points&#34;&gt;Data Points&lt;/h3&gt;
&lt;p&gt;For betweenness centrality:&lt;/p&gt;
&lt;p&gt;Date	Platform	# Processors	# Vertices	# Edges	# Samples	Time	Notes
22 Feb 2010	XMT@PNNL	128	537M	8.6B	256	55min	RMAT, scale 29, edgefactor 16&lt;/p&gt;
&lt;h3 id=&#34;download&#34;&gt;Download&lt;/h3&gt;
&lt;p&gt;Release version 0.8.0 is available September 21, 2012. Click &lt;a href=&#34;GraphCT-release-0.8.0.tar.gz&#34;&gt;here&lt;/a&gt; to download.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Multicore SWARM: Software and Algorithms for Running on Multicore Processors</title>
      <link>http://localhost:1313/projects/swarm/</link>
      <pubDate>Tue, 15 May 2007 07:21:37 -0400</pubDate>
      <guid>http://localhost:1313/projects/swarm/</guid>
      <description></description>
    </item>
    
    <item>
      <title>GRAPPA: Genome Rearrangements Analysis under Parsimony and other Phylogenetic Algorithms</title>
      <link>http://localhost:1313/projects/2004-grappa/</link>
      <pubDate>Fri, 31 Dec 2004 09:47:53 -0400</pubDate>
      <guid>http://localhost:1313/projects/2004-grappa/</guid>
      <description>&lt;p&gt;Copyright (C) 2000-2004, The University of New Mexico and The University of Texas at Austin&lt;/p&gt;
&lt;p&gt;This program is free software; you can redistribute it and/or modify it under the terms of the &lt;a href=&#34;http://www.gnu.org/copyleft/gpl.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GNU General Public License&lt;/a&gt; as published by the Free Software Foundation &amp;ndash; using version 2 (June 1991) of the License or (at your option) any later version.&lt;/p&gt;
&lt;p&gt;This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.&lt;/p&gt;
&lt;p&gt;You should have received a copy of or a link to the GNU General Public License along with this program; you can also write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.&lt;/p&gt;
&lt;p&gt;GRAPPA is available as a gzipped tar file containing all source files needed to compile an executable version. Documentation for this early release is minimal (there is a README file and some online help). GRAPPA changes quickly, so be sure to grab the latest release.&lt;/p&gt;
&lt;p&gt;GRAPPA was featured in Access, the magazine of the NCSA/Alliance in &lt;a href=&#34;http://www.ncsa.uiuc.edu/News/Access/Stories/phylogeny/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Vol. 14 (1)&lt;/a&gt; (Spring 2001). It is discussed at some length in&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Moret, B.M.E., Wyman, S., Bader, D.A., Warnow, T., and Yan, M., &amp;ldquo;A new implementation and detailed study of breakpoint analysis,&amp;rdquo; &lt;em&gt;Proc. 6th Pacific Symp. on Biocomputing (PSB 2001)&lt;/em&gt;, Hawaii, World Scientific Pub. (2001), 583-594. &lt;a href=&#34;psb1.ps&#34;&gt;PS&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Its linear-time computation of inversion distance is presented in&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Bader, D.A., Moret, B.M.E., and Yan, M., ``A linear-time algorithm for computing inversion distances between signed permutations with an experimental study,&amp;rsquo;&amp;rsquo; &lt;em&gt;Proc. 7th Workshop on Algorithms and Data Structures (WADS 01)&lt;/em&gt;, Providence (2001), Lecture Notes in Computer Science &lt;strong&gt;2125&lt;/strong&gt;, 365-376, Springer Verlag. Journal version appears in &lt;em&gt;J. Comput. Biol.&lt;/em&gt; &lt;strong&gt;8&lt;/strong&gt;, 5 (2001), 483-491. &lt;a href=&#34;jcb01.pdf&#34;&gt;PDF&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The improvements due to better bounding and new search ordering (the layered method) are discussed in&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Moret, B.M.E., Tang, J., Wang, L.S., and Warnow, T., &amp;ldquo;Steps toward accurate reconstruction of phylogenies from gene-order data,&amp;rdquo; to appear in &lt;em&gt;J. Comput. Syst. Sci.&lt;/em&gt; (invited, special issue on computational biology), 2002. &lt;a href=&#34;jcss.ps&#34;&gt;PS&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;while the improvements achieved through the use of true inversion medians are documented in&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Moret, B.M.E., Siepel, A.C., Tang, J., and Liu, T., &amp;ldquo;Inversion medians outperform breakpoint medians in phylogeny reconstruction from gene-order data,&amp;rdquo; &lt;em&gt;Proc. 2nd Int&amp;rsquo;l Workshop on Algorithms in Bioinformatics (WABI&#39;02)&lt;/em&gt;, Rome (2002), to appear in &lt;em&gt;Lecture Notes in Computer Science&lt;/em&gt; &lt;strong&gt;2452&lt;/strong&gt;, 2002. &lt;a href=&#34;wabi02a.ps&#34;&gt;PS&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;which also contains references to the works of A. Caprara and of A. Siepel, whose codes for the computation of true inversion medians are included in this release.
The latest release is&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;GRAPPA20.tar.gz&#34;&gt;GRAPPA-2.0&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;from October 1, 2004.
Previous releases (1.6 and 1.03) are obsolete.&lt;/p&gt;
&lt;p&gt;You may want to look at some &lt;a href=&#34;testsets.tar.gz&#34;&gt;test data&lt;/a&gt;.&lt;/p&gt;
&lt;pre&gt;
Authors (original):

    David A. Bader
    Electrical and Computer Engineering Department
    University of New Mexico
    Albuquerque, NM 87131
    +1.505.277.6724
    dbader@eece.unm.edu
    www.eece.unm.edu/~dbader

    Bernard M.E. Moret
    Department of Computer Science
    University of New Mexico
    Albuquerque, NM 87131
    +1.505.277.5699
    moret@cs.unm.edu
    www.cs.unm.edu/~moret

    Tandy Warnow
    Department of Computer Sciences
    University of Texas, Austin
    Austin, TX 78712
    +1.512.471.9724 
    tandy@cs.utexas.edu
    www.cs.utexas.edu/users/tandy/
     
    Stacia K Wyman
    Department of Computer Sciences
    University of Texas, Austin
    Austin, TX 78712
    +1.512.232.7432
    stacia@cs.utexas.edu
    www.cs.utexas.edu/users/stacia

    Mi Yan
    Electrical and Computer Engineering Department
    University of New Mexico
    Albuquerque, NM 87131
    +1.505.277.6185
    miyan@unm.edu
    www.ahpcc.unm.edu/~miyan/

Main contributors to version 1.6:

    Jijun Tang
    Department of Computer Science
    University of New Mexico
    Albuquerque, NM 87131
    jtang@cs.unm.edu

    Adam C. Siepel
    Department of Computer Science and Engineering
    University of California at Santa Cruz
    Santa Cruz, CA
    acs@cse.ucsc.edu

    Alberto Caprara
    DEIS
    Universit√° di Bologna
    40136 Bologna, Italy
    acaprara@deis.unibo.it

Main contributor to version 2.0:

    Jijun Tang
    Department of Computer Science and Engineering
    University of South Carolina
    jtang@cs.unm.edu


Maintainers:

    Bernard M.E. Moret moret@cs.unm.edu and Jijun Tang jtang@cs.unm.edu
&lt;/pre&gt;
&lt;p&gt;&lt;a href=&#34;https://www.cs.unm.edu/~moret/GRAPPA/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://www.cs.unm.edu/~moret/GRAPPA/&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
